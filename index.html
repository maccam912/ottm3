<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OVER THE TOP MATCH 3</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.js"></script>
  <style>
    html, body { height: 100%; margin: 0; background: radial-gradient(1200px 800px at 50% 30%, #0f172a 0%, #0b1025 40%, #070b1a 70%, #04060f 100%); }
    #game { width: 100%; height: 100%; }
    @font-face {
      font-family: 'Orbitron';
      src: url('https://fonts.gstatic.com/s/orbitron/v31/yMJRMIlzdpvBhQQL_Qq7dy1k.woff2') format('woff2');
      font-display: swap;
    }
  </style>
</head>
<body>
  <div id="game"></div>
  <script>
  // OVER THE TOP MATCH 3 â€” Phaser + Matter shards
  // Fix: ensure generated textures exist before first use. Remove fragile RenderTexture vignette.
  // Add: minimal self-tests for core match logic.

  const CONFIG = {
    COLS: 8,
    ROWS: 8,
    TILE: 72,
    TYPES: 6,
    GRAVITY_Y: 1.2,
    SHARDS_PER_TILE: 6,
  };

  const COLORS = [0xff4757, 0x70a1ff, 0x2ed573, 0xffd32a, 0xa29bfe, 0xff6b81];

  const W = 900;
  const H = 700;

  const BOARD_W = CONFIG.COLS * CONFIG.TILE;
  const BOARD_H = CONFIG.ROWS * CONFIG.TILE;
  const BOARD_X = Math.floor((W - BOARD_W) / 2);
  const BOARD_Y = Math.floor((H - BOARD_H) / 2) + 20;

  const state = {
    board: [], // {type, sprite}
    selected: null,
    inputLocked: false,
    score: 0,
    combo: 0,
    shardsCount: 0,
    testResults: []
  };

  const game = new Phaser.Game({
    type: Phaser.AUTO,
    width: W,
    height: H,
    parent: 'game',
    backgroundColor: 'transparent',
    physics: {
      default: 'matter',
      matter: {
        gravity: { y: CONFIG.GRAVITY_Y },
        enableSleeping: true,
      }
    },
    scene: { preload, create, update }
  });

  function preload() {
    // Nothing external to load. All textures are generated at runtime.
  }

  function create() {
    const scene = this;

    // World bounds for shards
    scene.matter.world.setBounds(0, 0, W, H, 32, true, true, true, true);

    // Vignette (simple, non-texture-based to avoid key issues)
    addVignette(scene);

    // Neon title
    scene.add.text(W/2, 46, 'OVER THE TOP MATCH 3', {
      fontFamily: 'Orbitron, Arial Black, Arial',
      fontSize: '32px',
      fontStyle: '900',
      color: '#ffffff',
      stroke: '#8b5cf6',
      strokeThickness: 6,
      shadow: { offsetX: 0, offsetY: 0, color: '#22d3ee', blur: 18, fill: true }
    }).setOrigin(0.5).setDepth(1000);

    // Score UI
    state.scoreText = scene.add.text(W/2, 86, 'Score 0', {
      fontFamily: 'Orbitron, Arial Black, Arial',
      fontSize: '22px',
      color: '#e2e8f0'
    }).setOrigin(0.5);

    // Board frame
    scene.add.rectangle(BOARD_X + BOARD_W/2, BOARD_Y + BOARD_H/2, BOARD_W + 14, BOARD_H + 14, 0x0b1025)
      .setStrokeStyle(4, 0x22d3ee, 0.9).setDepth(-5);

    // Generate textures BEFORE first use
    buildTileTextures(scene);
    buildParticleTextures(scene);
    ensureTexture(scene, 'spark');
    ensureTexture(scene, 'shard');

    // Particle manager
    state.particles = scene.add.particles('spark');

    // Initialize board
    initBoard(scene);

    // Input
    scene.input.on('pointerdown', (pointer) => onPointerDown(scene, pointer));

    // New Game button
    const btn = scene.add.text(W - 120, 24, 'New Game', {
      fontFamily: 'Orbitron, Arial', fontSize: '18px', color: '#10b981'
    }).setInteractive({ useHandCursor: true });
    btn.on('pointerdown', () => newGame(scene));

    // Run lightweight logic tests
    runTests(scene);
  }

  function update() {
    // Limit live shards to keep perf sane
    if (state.shardsCount > 450) {
      state.shardsCount = 0; // soft reset count
    }
  }

  // --- Setup helpers ---
  function addVignette(scene) {
    const g = scene.add.graphics({ x: 0, y: 0 });
    g.fillStyle(0x000000, 0.25);
    g.fillCircle(W/2, H*0.55, Math.max(W, H)*0.72);
    g.setDepth(2000);
  }

  function ensureTexture(scene, key) {
    if (!scene.textures.exists(key)) {
      // Fallback 2x2 white pixel to avoid key-missing crashes
      const c = scene.textures.createCanvas(key, 2, 2);
      const ctx = c.getContext();
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, 2, 2);
      c.refresh();
    }
  }

  function buildTileTextures(scene) {
    for (let i = 0; i < CONFIG.TYPES; i++) {
      const key = 'gem-' + i;
      if (scene.textures.exists(key)) continue;
      const g = scene.add.graphics();
      const s = CONFIG.TILE * 0.78;
      const r = 16;
      // Outer glow
      g.fillStyle(COLORS[i], 0.25);
      g.fillCircle(s/2, s/2, s/2);
      // Body
      g.fillStyle(COLORS[i], 1);
      g.fillRoundedRect((s - (s*0.86))/2, (s - (s*0.86))/2, s*0.86, s*0.86, r);
      // Gloss
      g.fillStyle(0xffffff, 0.25);
      g.fillEllipse(s*0.45, s*0.35, s*0.55, s*0.28);
      g.generateTexture(key, s, s);
      g.destroy();
    }
  }

  function buildParticleTextures(scene) {
    if (!scene.textures.exists('spark')) {
      const g1 = scene.add.graphics();
      g1.fillStyle(0xffffff, 1); g1.fillCircle(8, 8, 8); g1.generateTexture('spark', 16, 16); g1.destroy();
    }
    if (!scene.textures.exists('shard')) {
      const g2 = scene.add.graphics();
      g2.fillStyle(0xffffff, 1); g2.fillRoundedRect(0, 0, 12, 6, 2); g2.generateTexture('shard', 12, 6); g2.destroy();
    }
  }

  function newGame(scene) {
    // Clear existing
    for (let r = 0; r < CONFIG.ROWS; r++) {
      for (let c = 0; c < CONFIG.COLS; c++) {
        const t = state.board[r][c];
        if (t && t.sprite) t.sprite.destroy();
      }
    }
    state.board = [];
    state.score = 0; state.combo = 0; state.scoreText.setText('Score 0');
    initBoard(scene);
  }

  function initBoard(scene) {
    // Create a board with no initial matches
    for (let r = 0; r < CONFIG.ROWS; r++) {
      state.board[r] = [];
      for (let c = 0; c < CONFIG.COLS; c++) {
        let type;
        do { type = Phaser.Math.Between(0, CONFIG.TYPES - 1); }
        while (createsMatchAt(state.board, r, c, type));
        const sprite = makeTileSprite(scene, c, r, type);
        state.board[r][c] = { type, sprite };
      }
    }
  }

  function makeTileSprite(scene, c, r, type) {
    const key = 'gem-' + type;
    const s = scene.add.image(0, 0, key).setOrigin(0.5).setScale(1);
    const { x, y } = cellToXY(c, r);
    s.x = x; s.y = y;
    s.setInteractive();
    s.setData('c', c); s.setData('r', r);
    s.setDepth(10);
    // Idle pulsing tween
    scene.tweens.add({ targets: s, angle: { from: -2, to: 2 }, duration: 2400, yoyo: true, repeat: -1, ease: 'Sine.inOut' });
    return s;
  }

  // --- Input ---
  function onPointerDown(scene, pointer) {
    if (state.inputLocked) return;
    const { c, r } = xyToCell(pointer.x, pointer.y);
    if (!inBounds(c, r)) return;
    const tile = state.board[r][c];
    if (!tile || !tile.sprite) return;
    if (!state.selected) {
      selectTile(scene, tile);
    } else {
      const sel = state.selected;
      if (sel === tile) { deselectTile(scene, sel); return; }
      const sc = sel.sprite.getData('c');
      const sr = sel.sprite.getData('r');
      if (Math.abs(sc - c) + Math.abs(sr - r) === 1) {
        // Adjacent, attempt swap
        swapAttempt(scene, { c: sc, r: sr }, { c, r });
      } else {
        // New selection
        deselectTile(scene, sel);
        selectTile(scene, tile);
      }
    }
  }

  function selectTile(scene, tile) {
    state.selected = tile;
    scene.tweens.add({ targets: tile.sprite, scale: 1.12, duration: 80, yoyo: false });
    tile.sprite.setTint(0xffffff).setBlendMode(Phaser.BlendModes.SCREEN);
  }

  function deselectTile(scene, tile) {
    if (!tile || !tile.sprite) return;
    scene.tweens.add({ targets: tile.sprite, scale: 1.0, duration: 80 });
    tile.sprite.clearTint().setBlendMode(Phaser.BlendModes.NORMAL);
    state.selected = null;
  }

  // --- Swap + Resolve ---
  function swapAttempt(scene, a, b) {
    state.inputLocked = true;
    const aTile = state.board[a.r][a.c];
    const bTile = state.board[b.r][b.c];

    // Animate swap
    tweenSwap(scene, aTile.sprite, bTile.sprite, () => {
      // Commit swap in data
      swapCells(a, b);
      const matches = findMatches(state.board);
      if (matches.length > 0) {
        deselectTile(scene, aTile);
        resolveMatches(scene, matches);
      } else {
        // Swap back
        tweenSwap(scene, aTile.sprite, bTile.sprite, () => {
          swapCells(a, b); // revert
          state.inputLocked = false;
          deselectTile(scene, aTile);
        });
      }
    });
  }

  function tweenSwap(scene, s1, s2, onComplete) {
    const p1 = { x: s1.x, y: s1.y };
    const p2 = { x: s2.x, y: s2.y };
    scene.tweens.addCounter({ from: 0, to: 100, duration: 140, ease: 'Sine.inOut', onUpdate: t => {
      const k = t.progress;
      s1.x = Phaser.Math.Interpolation.Linear([p1.x, p2.x], k);
      s1.y = Phaser.Math.Interpolation.Linear([p1.y, p2.y], k);
      s2.x = Phaser.Math.Interpolation.Linear([p2.x, p1.x], k);
      s2.y = Phaser.Math.Interpolation.Linear([p2.y, p1.y], k);
    }, onComplete });
  }

  function swapCells(a, b) {
    const aTile = state.board[a.r][a.c];
    const bTile = state.board[b.r][b.c];
    // Swap data
    state.board[a.r][a.c] = bTile;
    state.board[b.r][b.c] = aTile;
    // Update sprite data
    bTile.sprite.setData('c', a.c).setData('r', a.r);
    aTile.sprite.setData('c', b.c).setData('r', b.r);
  }

  // --- Matching ---
  function createsMatchAt(board, r, c, type) {
    // Horizontal check
    if (c >= 2 && board[r][c-1] && board[r][c-2] && board[r][c-1].type === type && board[r][c-2].type === type) return true;
    // Vertical check
    if (r >= 2 && board[r-1][c] && board[r-2][c] && board[r-1][c].type === type && board[r-2][c].type === type) return true;
    return false;
  }

  function findMatches(board) {
    const matches = [];
    // Horizontal
    for (let r = 0; r < CONFIG.ROWS; r++) {
      let run = 1;
      for (let c = 1; c <= CONFIG.COLS; c++) {
        const same = c < CONFIG.COLS && board[r][c] && board[r][c-1] && board[r][c].type === board[r][c-1].type;
        if (same) run++; else {
          if (run >= 3) matches.push({ dir: 'h', r, c: c - run, len: run });
          run = 1;
        }
      }
    }
    // Vertical
    for (let c = 0; c < CONFIG.COLS; c++) {
      let run = 1;
      for (let r = 1; r <= CONFIG.ROWS; r++) {
        const same = r < CONFIG.ROWS && board[r][c] && board[r-1][c] && board[r][c].type === board[r-1][c].type;
        if (same) run++; else {
          if (run >= 3) matches.push({ dir: 'v', c, r: r - run, len: run });
          run = 1;
        }
      }
    }
    return matches;
  }

  function resolveMatches(scene, matches) {
    state.combo++;
    // Unique set of cells to clear
    const toClear = new Set();
    for (const m of matches) {
      if (m.dir === 'h') {
        for (let i = 0; i < m.len; i++) toClear.add(key(m.r, m.c + i));
      } else {
        for (let i = 0; i < m.len; i++) toClear.add(key(m.r + i, m.c));
      }
    }

    const clearList = [...toClear].map(k => parseKey(k));
    const tilesCleared = clearList.length;

    // VFX: camera shake + flash intensity by tilesCleared
    const intensity = Math.min(0.005 + tilesCleared * 0.0015, 0.025);
    scene.cameras.main.flash(120, 255, 255, 255);
    scene.cameras.main.shake(160, intensity);

    // Clear with explosions
    clearList.forEach(({r,c}) => explodeTile(scene, r, c));

    // Score
    const add = Math.floor(tilesCleared * 10 * Math.max(1, state.combo * 0.6));
    state.score += add;
    state.scoreText.setText(`Score ${state.score}`);

    // After explosions, drop tiles
    scene.time.delayedCall(180, () => {
      dropTiles(scene, () => {
        // Check for cascades
        const next = findMatches(state.board);
        if (next.length > 0) {
          resolveMatches(scene, next);
        } else {
          // No more matches; reset combo and unlock
          state.combo = 0;
          state.inputLocked = false;
        }
      });
    });
  }

  function explodeTile(scene, r, c) {
    const t = state.board[r][c];
    if (!t || !t.sprite) return;
    const { x, y } = cellToXY(c, r);

    // Burst particles
    const emitter = state.particles.createEmitter({
      x, y,
      speed: { min: 80, max: 350 },
      scale: { start: 0.9, end: 0 },
      alpha: { start: 1, end: 0 },
      lifespan: { min: 250, max: 600 },
      quantity: 14,
      angle: { min: 0, max: 360 },
      blendMode: 'ADD',
      tint: COLORS[t.type]
    });
    scene.time.delayedCall(160, () => emitter.stop());

    // Matter shards
    spawnShards(scene, x, y, COLORS[t.type]);

    // Pop animation then remove
    scene.tweens.add({ targets: t.sprite, scale: 1.4, alpha: 0, duration: 130, ease: 'Back.easeIn', onComplete: () => t.sprite.destroy() });

    // Clear tile
    state.board[r][c] = { type: null, sprite: null };
  }

  function spawnShards(scene, x, y, color) {
    for (let i = 0; i < CONFIG.SHARDS_PER_TILE; i++) {
      const shard = scene.matter.add.image(x, y, 'shard', undefined, { restitution: 0.9, frictionAir: 0.02, slop: 0.5 });
      shard.setTint(color);
      shard.setScale(Phaser.Math.FloatBetween(0.7, 1.3));
      shard.setBounce(0.9);
      shard.setFriction(0.005, 0.0001, 0.0001);
      const sp = Phaser.Math.Between(160, 520);
      const ang = Phaser.Math.FloatBetween(0, Math.PI * 2);
      shard.setVelocity(Math.cos(ang) * sp / 100, Math.sin(ang) * sp / 100 - 2);
      shard.setAngularVelocity(Phaser.Math.FloatBetween(-0.25, 0.25));
      shard.setIgnoreGravity(false);
      state.shardsCount++;
      scene.time.delayedCall(1500 + Math.random()*800, () => shard.destroy());
    }
  }

  // --- Gravity / Refill ---
  function dropTiles(scene, onComplete) {
    const promises = [];
    for (let c = 0; c < CONFIG.COLS; c++) {
      let writeRow = CONFIG.ROWS - 1;
      for (let r = CONFIG.ROWS - 1; r >= 0; r--) {
        const t = state.board[r][c];
        if (t && t.type !== null) {
          if (writeRow !== r) {
            // Move tile down
            const dest = cellToXY(c, writeRow);
            promises.push(tweenTo(scene, t.sprite, dest.x, dest.y));
            t.sprite.setData('r', writeRow);
            state.board[writeRow][c] = t;
            state.board[r][c] = { type: null, sprite: null };
          }
          writeRow--;
        }
      }
      // Spawn new tiles at top
      for (let r = writeRow; r >= 0; r--) {
        const type = Phaser.Math.Between(0, CONFIG.TYPES - 1);
        const s = makeTileSprite(scene, c, r, type);
        const start = cellToXY(c, -1 - Phaser.Math.Between(0, 2));
        s.x = start.x; s.y = start.y;
        const dest = cellToXY(c, r);
        s.alpha = 0; s.scale = 0.8;
        const t = { type, sprite: s };
        state.board[r][c] = t;
        promises.push(new Promise(res => {
          scene.tweens.add({ targets: s, x: dest.x, y: dest.y, alpha: 1, scale: 1, duration: 220 + (writeRow - r) * 30, ease: 'Back.out', onComplete: res });
        }));
      }
    }
    Promise.all(promises).then(() => onComplete && onComplete());
  }

  function tweenTo(scene, sprite, x, y) {
    return new Promise(res => {
      scene.tweens.add({ targets: sprite, x, y, duration: 160, ease: 'Quad.out', onComplete: res });
    });
  }

  // --- Utilities ---
  function inBounds(c, r) { return c >= 0 && c < CONFIG.COLS && r >= 0 && r < CONFIG.ROWS; }
  function cellToXY(c, r) { return { x: BOARD_X + c * CONFIG.TILE + CONFIG.TILE/2, y: BOARD_Y + r * CONFIG.TILE + CONFIG.TILE/2 }; }
  function xyToCell(x, y) { return { c: Math.floor((x - BOARD_X) / CONFIG.TILE), r: Math.floor((y - BOARD_Y) / CONFIG.TILE) }; }
  function key(r, c) { return r + ':' + c; }
  function parseKey(k) { const [r,c] = k.split(':').map(Number); return { r, c }; }

  // --- Pure helpers for tests ---
  function wouldSwapCreateMatch(board, a, b, rows = CONFIG.ROWS, cols = CONFIG.COLS) {
    // shallow clone indices only
    const clone = board.map(row => row.slice());
    const tmp = clone[a.r][a.c];
    clone[a.r][a.c] = clone[b.r][b.c];
    clone[b.r][b.c] = tmp;
    // reuse logic with temporary globals
    const oldRows = CONFIG.ROWS, oldCols = CONFIG.COLS;
    CONFIG.ROWS = rows; CONFIG.COLS = cols;
    const had = findMatches(clone).length > 0;
    CONFIG.ROWS = oldRows; CONFIG.COLS = oldCols;
    return had;
  }

  function toBoard(types2D) {
    return types2D.map(row => row.map(t => ({ type: t, sprite: {} })));
  }

  function runTests(scene) {
    // Test 1: horizontal detection
    const b1 = toBoard([
      [0,0,0,1,2,3,4,5],
      [1,2,3,4,5,0,1,2],
      [2,3,4,5,0,1,2,3],
      [3,4,5,0,1,2,3,4],
      [4,5,0,1,2,3,4,5],
      [5,0,1,2,3,4,5,0],
      [0,1,2,3,4,5,0,1],
      [1,2,3,4,5,0,1,2],
    ]);
    const m1 = findMatches(b1);
    state.testResults.push(['horizontal >=1', m1.some(m => m.dir==='h' && m.len>=3)]);

    // Test 2: vertical detection
    const b2 = toBoard([
      [0,1,2,3,4,5,0,1],
      [0,2,3,4,5,0,1,2],
      [0,3,4,5,0,1,2,3],
      [0,4,5,0,1,2,3,4],
      [4,5,0,1,2,3,4,5],
      [5,0,1,2,3,4,5,0],
      [0,1,2,3,4,5,0,1],
      [1,2,3,4,5,0,1,2],
    ]);
    const m2 = findMatches(b2);
    state.testResults.push(['vertical >=1', m2.some(m => m.dir==='v' && m.len>=3)]);

    // Test 3: wouldSwapCreateMatch positive
    const b3 = toBoard([
      [0,1,2,3,4,5,0,1],
      [1,1,2,3,4,5,0,1],
      [1,2,2,3,4,5,0,1],
      [3,4,5,0,1,2,3,4],
      [4,5,0,1,2,3,4,5],
      [5,0,1,2,3,4,5,0],
      [0,1,2,3,4,5,0,1],
      [1,2,3,4,5,0,1,2],
    ]);
    state.testResults.push(['swap makes match', wouldSwapCreateMatch(b3, {r:1,c:0},{r:0,c:0}, 8,8)]);

    // Test 4: initial board has no matches
    const tempScene = { ...scene };
    const saved = JSON.parse(JSON.stringify(state.board.map(row => row.map(t=>t? t.type:null))));
    const initialMatches = findMatches(state.board);
    state.testResults.push(['initial board clean', initialMatches.length===0]);

    // Display test summary
    const passed = state.testResults.filter(([_, ok]) => ok).length;
    scene.add.text(12, 12, `Tests: ${passed}/${state.testResults.length} passed`, { fontFamily: 'monospace', fontSize: '14px', color: passed===state.testResults.length ? '#10b981' : '#f97316' })
      .setScrollFactor(0).setDepth(3000);

    // Log details
    console.table(state.testResults.map(([name, ok]) => ({ test: name, passed: ok })));
  }

  </script>
</body>
</html>
